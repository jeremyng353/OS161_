Step 4:
jharvard@appliance (~/os161/root): sys161 kernel
sys161: System/161 release 2.0.3, compiled Sep 12 2021 20:13:15

OS/161 base system version 1.99.08
Copyright (c) 2000, 2001-2005, 2008-2011, 2013, 2014
   President and Fellows of Harvard College.  All rights reserved.

Put-your-group-name-here's system version 0 (DUMBVM #1)

292k physical memory available
Device probe...
lamebus0 (system main bus)
emu0 at lamebus0
ltrace0 at lamebus0
ltimer0 at lamebus0
beep0 at ltimer0
rtclock0 at ltimer0
lrandom0 at lamebus0
random0 at lrandom0
lhd0 at lamebus0
lhd1 at lamebus0
lser0 at lamebus0
con0 at lser0

cpu0: MIPS/161 (System/161 2.x) features 0x0
OS/161 kernel [? for menu]: 

jharvard@appliance (~/os161/src): git log
commit 99e56a0d05bb3e6b897c423d35eb61df439b0b14
Author: Jeremy Ng <kliong31@gmail.com>
Date:   Sun Sep 12 20:22:54 2021 -0400

    Initial commit of os161 for CPEN331

jharvard@appliance (~/os161/src): git tag
asst1-start

Step 5:
Question 1: When a trap or exception happens, the exception handlers in exception-mips1.S run. If it's a UTLB exception, then 
    mips_utlb_handler runs, while for other exceptions the mips_general_handler runs. They both transfer control to common_exception. 
    However, for traps, it gets sent to mips_traps eventually. 
    
Question 2: In kern/arch/mips/locore/trap.c on line 224, mips_trap makes a syscall. 

Question 3: The libc functions in common are for both the kernel and user programs to use, while libc functions in userland are 
    specifically for user programs to use.
    
Question 4: The configure file sets the default location for the root of os161 and sets the debug flag to optimize. The configuration 
    may be invalidated when running on a different host OS, so configure would need to be run again.
    
Question 5: Code that relies on specific addresses or registers will be machine dependent, since different operating systems will have 
    different addresses set apart for kernel/user programs. By separating machine dependent code and non-machine dependent code, it would
    be easier to change the code to be suitable for other operationg systems (modularity).
    
Question 6: Since there are 37 uint32_t's in a trapframe, and each one is 4 bytes, the total size is 148 bytes (lines 40-78, trapframe.h).

Question 7: Whenever anything in the source tree is edited, the config script should be run to check that the configuration is possible and
    to set up the compile diectory, makefiles, and associated materials (lines 36-39, kern/conf/config).
    
Question 8: Whenever dependencies such as header files have been added, removed, or changed, since bmake depend updates make dependency info 
    (Makefile).

Question 9: Whenever source code has been changed, run bmake to compile and install. On the other hand, bmake install can be used to install
    to a specific location $(OSTREE) (Makefile).

Question 10: To add such a command, I would add the following code to kern/main/menu.c
static int cmd_hello_world(int nargs, char **args) {
    (void)nargs;
    (void)args;
    kprintf("Hello world!");
    return 0;
}

Question 11: The code needs to be standardized so that it works regardless of whatever platform you're running it on. You can't rely on the
    standard utilities present on whatever machine you're working on because different users will have different machines, and therefore
    different standard utilities.
    
Question 12: The return value is used to check whether the program exited normally or if there was an error while running the program.

Question 13: Define a syscall number for the new syscall function in kern/include/kern/syscall, and then add it to the switch statement in
    kern/arch/mips/sysall/syscall.c. To test this, I would rerun the kern/conf/config script and then bmake in the respective kernel. 

Step 7:
Question 14: __start

Question 15: .frame sp, 24, $0
(gdb) list
49	    * when we switch off the bootup stack. Otherwise, gdb gets very
50	    * confused.
51	    */
52	   .frame sp, 24, $0	/* 24-byte sp-relative frame; return addr on stack */

Question 16: 
(gdb) info b
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x800139e4 in kmain at ../../main/main.c:211
	breakpoint already hit 1 time
2       breakpoint     keep y   0x80014a0c in menu at ../../main/menu.c:697
	breakpoint already hit 1 time

Question 17: The return address is saved, _end is generated by linker, boot stack is set up for first processor, exception handler
    code is copied to first page of memory, instruction cache is flushed, CST_IRQMASK is written to status register, CPU number gets
    loaded into PTBASE field of CONTEXT Register, and GP register gets loaded with address in the middle of data segment.

Question 18: jal kmain

Question 19: ram_bootstrap, proc_bootstrap, thread_bootstrap, hardclock_bootstrap, vfs_bootstrap, kheap_nextgeneration
break kmain
c
s
s 
(gdb) list
107	
108		/* Early initialization. */
109		ram_bootstrap();
110		proc_bootstrap();
111		thread_bootstrap();
112		hardclock_bootstrap();
113		vfs_bootstrap();
114		kheap_nextgeneration();

Question 20:
break kmain
c
s
break thread_bootstrap
c 
(gdb) p *bootcpu
Cannot access memory at address 0x80000

Question 21:
(gdb) p *bootcpu
$2 = {c_self = 0x8003af00, c_number = 0, c_hardware_number = 0, 
  c_curthread = 0x8003bf80, c_zombies = {tl_head = {tln_prev = 0x0, 
      tln_next = 0x8003af1c, tln_self = 0x0}, tl_tail = {
      tln_prev = 0x8003af10, tln_next = 0x0, tln_self = 0x0}, tl_count = 0}, 
  c_hardclocks = 0, c_spinlocks = 0, c_isidle = false, c_runqueue = {
    tl_head = {tln_prev = 0x0, tln_next = 0x8003af44, tln_self = 0x0}, 
    tl_tail = {tln_prev = 0x8003af38, tln_next = 0x0, tln_self = 0x0}, 
    tl_count = 0}, c_runqueue_lock = {splk_lock = 0, splk_holder = 0x0}, 
  c_ipi_pending = 0, c_shootdown = {{ts_placeholder = 0} <repeats 16 times>}, 
  c_numshootdown = 0, c_ipi_lock = {splk_lock = 0, splk_holder = 0x0}}

Question 22:
(gdb) cpuarray allcpus
0 cpus

Question 23:
break kmain
c
n
(gdb) cpuarray allcpus
1 cpus
cpu 0:
$1 = {c_self = 0x8003af00, c_number = 0, c_hardware_number = 0, 
  c_curthread = 0x8003bf80, c_zombies = {tl_head = {tln_prev = 0x0, 
      tln_next = 0x8003af1c, tln_self = 0x0}, tl_tail = {
      tln_prev = 0x8003af10, tln_next = 0x0, tln_self = 0x0}, tl_count = 0}, 
  c_hardclocks = 1, c_spinlocks = 0, c_isidle = false, c_runqueue = {
    tl_head = {tln_prev = 0x0, tln_next = 0x8003af44, tln_self = 0x0}, 
    tl_tail = {tln_prev = 0x8003af38, tln_next = 0x0, tln_self = 0x0}, 
    tl_count = 0}, c_runqueue_lock = {splk_lock = 0, splk_holder = 0x0}, 
  c_ipi_pending = 0, c_shootdown = {{ts_placeholder = 0} <repeats 16 times>}, 
  c_numshootdown = 0, c_ipi_lock = {splk_lock = 0, splk_holder = 0x0}}




